"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.K2Tool = void 0;
const web3_js_1 = require("@_koi/web3.js");
const bip39_1 = require("bip39");
const bs58_1 = __importDefault(require("bs58"));
const ed25519_hd_key_1 = require("ed25519-hd-key");
const constants_1 = require("./constants");
class K2Tool {
    constructor(credentials, rpcUrl) {
        this.key = null;
        this.address = null;
        this.keypair = null;
        if (credentials) {
            this.key = credentials.key;
            this.address = credentials.address;
            this.keypair = web3_js_1.Keypair.fromSecretKey(new Uint8Array(credentials.key.split(",").map((value) => Number(value))));
        }
        if (!rpcUrl)
            rpcUrl = "https://testnet.koii.network";
        this.rpcUrl = rpcUrl;
        this.connection = new web3_js_1.Connection(rpcUrl, "confirmed");
    }
    getCurrentNetwork() {
        return this.rpcUrl;
    }
    generateKoiiCliWallet(key) {
        try {
            const seed = (0, bip39_1.mnemonicToSeedSync)(key);
            const keypair = web3_js_1.Keypair.fromSeed(Uint8Array.from(Uint8Array.from(seed)).slice(0, 32));
            return keypair;
        }
        catch (err) {
            console.error("generateKoiiCliWallet", err);
            return null;
        }
    }
    async importAllPossibleWallets(key) {
        const bufferToString = (buffer) => Buffer.from(buffer).toString("hex");
        const deriveSeed = (seed) => (0, ed25519_hd_key_1.derivePath)(constants_1.K2_DEFAULT_DERIVATION_PATH, seed).key;
        const wallets = [];
        const seed = (0, bip39_1.mnemonicToSeedSync)(key);
        const keypair = web3_js_1.Keypair.fromSeed(deriveSeed(bufferToString(seed)));
        const koiiCliKeypair = this.generateKoiiCliWallet(key);
        wallets.push({
            address: keypair.publicKey.toBase58(),
            pathType: "default"
        });
        koiiCliKeypair &&
            wallets.push({
                address: koiiCliKeypair.publicKey.toBase58(),
                pathType: "cli"
            });
        return wallets;
    }
    async importWalletByDerivationPath(seedphrase, pathType) {
        let keypair;
        if (pathType === "default") {
            const bufferToString = (buffer) => Buffer.from(buffer).toString("hex");
            const deriveSeed = (seed) => (0, ed25519_hd_key_1.derivePath)(constants_1.K2_DEFAULT_DERIVATION_PATH, seed).key;
            const seed = (0, bip39_1.mnemonicToSeedSync)(seedphrase);
            keypair = web3_js_1.Keypair.fromSeed(deriveSeed(bufferToString(seed)));
        }
        else if (pathType === "cli") {
            keypair = this.generateKoiiCliWallet(seedphrase);
        }
        if (!keypair) {
            throw new Error("Keypair is currently null");
        }
        this.keypair = keypair;
        this.address = keypair.publicKey.toString();
        this.key = keypair.secretKey.toString();
        const wallet = {
            address: this.address,
            privateKey: this.key
        };
        return wallet;
    }
    async importWallet(key, type) {
        let keypair;
        /* Helper functions */
        const bufferToString = (buffer) => Buffer.from(buffer).toString("hex");
        const deriveSeed = (seed) => (0, ed25519_hd_key_1.derivePath)(constants_1.K2_DEFAULT_DERIVATION_PATH, seed).key;
        const keypairs = [];
        if (type === "seedphrase") {
            const seed = (0, bip39_1.mnemonicToSeedSync)(key);
            keypair = web3_js_1.Keypair.fromSeed(deriveSeed(bufferToString(seed)));
            const koiiCliKeypair = this.generateKoiiCliWallet(key);
            keypairs.push(keypair);
            koiiCliKeypair && keypairs.push(koiiCliKeypair);
        }
        else {
            const secretKey = bs58_1.default.decode(key);
            keypair = web3_js_1.Keypair.fromSecretKey(secretKey);
        }
        for (const kp of keypairs) {
            const balance = await this.connection.getBalance(kp.publicKey);
            if (balance > 0) {
                keypair = kp;
                break;
            }
        }
        this.keypair = keypair;
        this.address = keypair.publicKey.toString();
        this.key = keypair.secretKey.toString();
        const wallet = {
            address: this.address,
            privateKey: this.key
        };
        return wallet;
    }
    async generateWallet() {
        const seedPhrase = (0, bip39_1.generateMnemonic)();
        await this.importWallet(seedPhrase, "seedphrase");
        return seedPhrase;
    }
    async getBalance() {
        if (!this.keypair) {
            throw new Error("Cannot get the balance");
        }
        const balance = await this.connection.getBalance(this.keypair.publicKey);
        return balance;
    }
    async transfer(recipient, amount) {
        try {
            if (!this.keypair) {
                throw new Error("Keypair is currently null");
            }
            const transaction = new web3_js_1.Transaction();
            transaction.add(web3_js_1.SystemProgram.transfer({
                fromPubkey: this.keypair.publicKey,
                toPubkey: new web3_js_1.PublicKey(recipient),
                lamports: amount * web3_js_1.LAMPORTS_PER_SOL
            }));
            const receipt = await (0, web3_js_1.sendAndConfirmTransaction)(this.connection, transaction, [this.keypair]);
            return receipt;
        }
        catch (err) {
            if (err instanceof Error)
                throw new Error(err.message);
        }
    }
}
exports.K2Tool = K2Tool;
//# sourceMappingURL=k2.js.map